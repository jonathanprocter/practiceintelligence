#!/usr/bin/env python3
"""
FIXED PyMyPDF Bidirectional Export Script

This version includes:
- Better error handling
- Improved event filtering
- Detailed logging
- Fallback mechanisms
"""

import json
import sys
import os
from datetime import datetime, timedelta
from typing import List, Dict, Any

def safe_parse_datetime(date_str: str) -> datetime:
    """Safely parse datetime string with multiple format support."""
    if not date_str:
        return None
    
    # Try different parsing methods
    methods = [
        # Standard ISO format
        lambda d: datetime.fromisoformat(d.replace('Z', '+00:00')),
        # With milliseconds
        lambda d: datetime.fromisoformat(d.split('.')[0].replace('Z', '+00:00')),
        # Space-separated format
        lambda d: datetime.strptime(d, '%Y-%m-%d %H:%M:%S'),
        # Alternative ISO format
        lambda d: datetime.strptime(d.replace('Z', ''), '%Y-%m-%dT%H:%M:%S'),
    ]
    
    for method in methods:
        try:
            return method(date_str)
        except:
            continue
    
    return None

def filter_events_for_week_safe(events_data: List[Dict], week_start: datetime, week_end: datetime) -> List[Dict]:
    """Safely filter events with detailed logging."""
    
    week_events = []
    parsing_errors = 0
    
    print(f"🔍 Filtering {len(events_data)} events for week {week_start.date()} to {week_end.date()}")
    
    for i, event in enumerate(events_data):
        try:
            event_start_str = event.get('startTime', '')
            if not event_start_str:
                continue
                
            event_date = safe_parse_datetime(event_start_str)
            
            if event_date:
                if week_start <= event_date <= week_end:
                    week_events.append(event)
                    if len(week_events) <= 5:  # Log first 5 matches
                        print(f"  ✅ Event {i+1}: {event.get('title', 'Untitled')} on {event_date.date()}")
            else:
                parsing_errors += 1
                if parsing_errors <= 3:  # Log first 3 errors
                    print(f"  ❌ Could not parse date: {event_start_str}")
                
        except Exception as e:
            parsing_errors += 1
            if parsing_errors <= 3:
                print(f"  ❌ Error processing event {i+1}: {e}")
    
    print(f"📊 Filtered {len(week_events)} events ({parsing_errors} parsing errors)")
    return week_events

def create_bidirectional_pdf_safe(events_data: List[Dict], week_start_str: str, week_end_str: str) -> str:
    """Create PDF with comprehensive error handling."""
    
    try:
        # Parse dates safely
        week_start = safe_parse_datetime(week_start_str)
        week_end = safe_parse_datetime(week_end_str)
        
        if not week_start or not week_end:
            raise ValueError(f"Could not parse week dates: {week_start_str}, {week_end_str}")
        
        # Filter events
        week_events = filter_events_for_week_safe(events_data, week_start, week_end)
        
        # Generate filename
        filename = f"bidirectional_weekly_planner_{week_start.strftime('%Y-%m-%d')}.pdf"
        
        print(f"🔗 Creating PDF: {filename}")
        print(f"📊 Processing {len(week_events)} events")
        
        # Try to create PDF
        try:
            import fitz
            
            # Create PDF document
            doc = fitz.open()
            
            # Page 1: Weekly Overview (Landscape)
            weekly_page = doc.new_page(width=792, height=612)
            create_weekly_page_safe(weekly_page, week_events, week_start)
            
            # Pages 2-8: Daily Pages (Portrait)
            days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
            for i, day_name in enumerate(days):
                current_date = week_start + timedelta(days=i)
                daily_page = doc.new_page(width=612, height=792)
                create_daily_page_safe(daily_page, week_events, current_date, day_name, i)
            
            # Add hyperlinks
            add_hyperlinks_safe(doc)
            
            # Save document
            doc.save(filename)
            doc.close()
            
            print(f"✅ Successfully created PDF: {filename}")
            return filename
            
        except ImportError:
            print("❌ PyMuPDF not available, creating text fallback")
            return create_text_fallback_safe(events_data, week_start, week_end)
        except Exception as e:
            print(f"❌ PDF creation failed: {e}")
            return create_text_fallback_safe(events_data, week_start, week_end)
            
    except Exception as e:
        print(f"❌ Critical error: {e}")
        return create_error_fallback(str(e))

def create_weekly_page_safe(page, events, week_start):
    """Create weekly page with error handling."""
    try:
        # Title
        page.insert_text((50, 50), "WEEKLY PLANNER", fontsize=24)
        page.insert_text((50, 80), f"{week_start.strftime('%B %d, %Y')} - {(week_start + timedelta(days=6)).strftime('%B %d, %Y')}", fontsize=14)
        
        # Simple grid
        days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
        for i, day in enumerate(days):
            x = 50 + (i * 100)
            page.insert_text((x, 120), day, fontsize=12)
            
            # Count events for this day
            current_date = week_start + timedelta(days=i)
            day_events = [e for e in events if is_event_on_date_safe(e, current_date)]
            page.insert_text((x, 140), f"{len(day_events)} events", fontsize=10)
            
    except Exception as e:
        print(f"❌ Error creating weekly page: {e}")

def create_daily_page_safe(page, events, date, day_name, day_index):
    """Create daily page with error handling."""
    try:
        # Header
        page.insert_text((50, 50), f"{day_name}, {date.strftime('%B %d, %Y')}", fontsize=20)
        
        # Navigation buttons
        page.insert_text((50, 80), "📅 Weekly Overview", fontsize=12)
        if day_index > 0:
            page.insert_text((200, 80), "← Previous", fontsize=12)
        if day_index < 6:
            page.insert_text((300, 80), "Next →", fontsize=12)
        
        # Events
        day_events = [e for e in events if is_event_on_date_safe(e, date)]
        page.insert_text((50, 120), f"{len(day_events)} appointments", fontsize=14)
        
        # List events
        y = 150
        for event in day_events[:10]:  # Show up to 10 events
            title = event.get('title', 'Untitled')[:50]
            time_str = safe_parse_datetime(event.get('startTime', ''))
            time_display = time_str.strftime('%H:%M') if time_str else '00:00'
            
            page.insert_text((50, y), f"{time_display} - {title}", fontsize=10)
            y += 20
            
    except Exception as e:
        print(f"❌ Error creating daily page: {e}")

def add_hyperlinks_safe(doc):
    """Add hyperlinks with error handling."""
    try:
        import fitz
        
        # Weekly page links to daily pages
        weekly_page = doc[0]
        for i in range(7):
            x = 50 + (i * 100)
            rect = fitz.Rect(x, 120, x + 90, 160)
            weekly_page.insert_link({
                "kind": fitz.LINK_GOTO,
                "from": rect,
                "page": i + 1,
                "to": fitz.Point(0, 0)
            })
        
        # Daily pages link back to weekly
        for i in range(7):
            daily_page = doc[i + 1]
            rect = fitz.Rect(50, 80, 180, 100)
            daily_page.insert_link({
                "kind": fitz.LINK_GOTO,
                "from": rect,
                "page": 0,
                "to": fitz.Point(0, 0)
            })
            
    except Exception as e:
        print(f"❌ Error adding hyperlinks: {e}")

def is_event_on_date_safe(event, target_date):
    """Safely check if event is on target date."""
    try:
        event_start = event.get('startTime', '')
        if event_start:
            event_date = safe_parse_datetime(event_start)
            if event_date:
                return event_date.date() == target_date.date()
    except:
        pass
    return False

def create_text_fallback_safe(events_data, week_start, week_end):
    """Create text fallback with error handling."""
    try:
        filename = f"bidirectional_weekly_planner_{week_start.strftime('%Y-%m-%d')}.txt"
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("BIDIRECTIONAL WEEKLY PLANNER\n")
            f.write("=" * 50 + "\n")
            f.write(f"Week: {week_start.strftime('%B %d, %Y')} - {week_end.strftime('%B %d, %Y')}\n")
            f.write(f"Events: {len(events_data)}\n\n")
            f.write("Note: PDF generation not available, created text version.\n")
        
        print(f"✅ Created text fallback: {filename}")
        return filename
        
    except Exception as e:
        print(f"❌ Text fallback failed: {e}")
        return create_error_fallback(str(e))

def create_error_fallback(error_msg):
    """Create minimal error file."""
    filename = f"error_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    try:
        with open(filename, 'w') as f:
            f.write(f"ERROR: {error_msg}\n")
        return filename
    except:
        return None

def main():
    """Main function with comprehensive error handling."""
    try:
        # Read input
        input_data = sys.stdin.read().strip()
        
        if not input_data:
            print("❌ No input data received")
            sys.exit(1)
        
        # Parse JSON
        data = json.loads(input_data)
        
        events = data.get('events', [])
        week_start = data.get('weekStart', '')
        week_end = data.get('weekEnd', '')
        
        print(f"📊 Received {len(events)} events")
        print(f"📅 Week: {week_start} to {week_end}")
        
        # Create PDF
        filename = create_bidirectional_pdf_safe(events, week_start, week_end)
        
        if filename:
            print(filename)  # Output filename for backend
        else:
            print("❌ Failed to create any output")
            sys.exit(1)
            
    except json.JSONDecodeError as e:
        print(f"❌ JSON parsing error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"❌ Unexpected error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
